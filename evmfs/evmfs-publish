#!/usr/bin/env bash

# SPDX-License-Identifier: AGPL-3.0-or-later

#    ----------------------------------------------------------------------
#    Copyright Â© 2024, 2025  Pellegrino Prevete
#
#    All rights reserved
#    ----------------------------------------------------------------------
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

_bin="$( \
  dirname \
    "$( \
      command \
        -v \
	  "env")")"
_lib="$( \
  realpath \
    "${_bin}/../lib")"
_crash_bash="${_lib}/libcrash-bash/crash-bash"
_libevm="${_lib}/libevm/libevm"
_sourced \
  "${_crash_bash}" 2>/dev/null || \
  source \
    "${_crash_bash}"
_sourced \
  "${_libevm}"

# shellcheck disable=SC2034
_global_variables() {
  publish_date=""
  fs_address=""
  fs_version=""
  ll_address=""
  ccfs_address=""
  deployments_dir=""
  user_level=""
  wallet_name=""
  wallet_path=""
  wallet_password=""
  wallet_seed=""
  wallet_address=""
  networks_amount=""
  target_network=""
  target_networks=()
  api_key=""
  upload_method=""
  retries_max=""
  call_timeout=""
  lock_only=""
  tasks_parallel=""
  cache_dir=""
  target_files=()
  command_args=()
  color=""
  quiet=""
}

_requirements() {
  _check_cmd \
    'libevm-requirements' \
    'libevm'
  libevm-requirements
  _check_cmd \
    'evm-contract-call' \
    'evm-contracts-tools'
  _check_cmd \
    'evm-contract-deployment-networks' \
    'evm-contracts-tools'
  _check_cmd \
    'evm-wallet'
  _check_cmd \
    'bin2txt' \
    'encoding-tools'
  _check_cmd \
    'txt2bin' \
    'encoding-tools'
  _check_cmd \
    'node-run'
}

_get_conf_dir_path() {
  local \
    _dir
  _dir="${HOME}/.config/evmfs"
  echo \
    "${_dir}"
}

_cache_dir_auto_detect() {
  local \
    _dir
  _dir="${HOME}/.cache/evmfs"
  echo \
    "${_dir}"
}

_file_size_check() {
  local \
    _file="${1}" \
    _size \
    _msg=()
  _chunks_many="false"
  _size="$( \
    du \
      -b \
      "${_file}" | \
      awk '{print $1}')"
  _msg=(
    "file '${_file}' has size '${_size}' bytes"
  )
  _msg_info \
    "${_msg[*]}"
  if (( 22000 < "${_size}" )); then
    _msg_info \
      "writing over more than a single string!"
    _chunks_many="true"
  fi
}

_chunk_verify() {
  local \
    _contract="${1}" \
    _namespace="${2}" \
    _sum="${3}" \
    _index="${4}" \
    _chunk="${5}" \
    _remote \
    _verify_dir \
    _local_sum \
    _remote_sum \
    _publishing_address \
    _msg=()
  _verify_dir="${_cache_dir}/${_sum}/verify"
  _remote="${_verify_dir}/${_index}"
  mkdir \
    -p \
    "${_verify_dir}"
  evm-contract-call \
    "${_verify_call_opts[@]}" \
    "${_fs_address}" \
    "chunks" \
    "${_namespace}" \
    "${_sum}" \
    "${_index}" > \
    "${_remote}"
  _local_sum="$( \
    _file_hash \
      "${_chunk}")"
  _remote_sum="$( \
    _file_hash \
      "${_remote}")"
  if [[ "${_local_sum}" != "${_remote_sum}" ]]; then
    _publishing_address=$( \
      _publishing_address_get \
        "${_file}")
    _msg=(
      "Somehow local chunk '${_chunk}',"
      "corresponding to chunk having"
      "index '${_index}' on the blockchain"
      "has not been written correctly"
      "on the blockchain at address '${_publishing_address}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_chunk_lock() {
  local \
    _contract="${1}" \
    _namespace="${2}" \
    _sum="${3}" \
    _index="${4}" \
    _msg=() \
    _locked
  _locked="$( \
    evm-contract-call \
      "${_check_call_opts[@]}" \
      "${_fs_address}" \
      "lock" \
      "${_namespace}" \
      "${_sum}" \
      "${_index}")"
  if [[ "${_locked}" == "false" ]]; then
    evm-contract-call \
      "${_lock_call_opts[@]}" \
      "${_fs_address}" \
      "lockChunk" \
      "${_namespace}" \
      "${_sum}" \
      "${_index}"
    _msg=(
      "chunk '${_chunk}'"
      "$(( "${_index}" + 1))"
      "of ${_chunks_total}"
      "correctly locked."
    )
  elif [[ "${_locked}" == "true" ]]; then
    _msg=(
      "chunk '${_chunk}'"
      "$(( "${_index}" + 1))"
      "of ${_chunks_total}"
      "already locked."
    )
  elif [[ "${_locked}" == "" ]]; then
    _msg=(
      "Error retrieving lock state"
      "for chunk '${_chunk}'"
      "$(( "${_index}" + 1))"
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _msg_info \
    "${_msg[*]}"
}

_file_hash() {
  local \
    _file="${1}"
  sha256sum \
    "${_file}" | \
    awk \
      '{print $1}'
}

_chunk_publish() {
  local \
    _fs_address="${1}" \
    _namespace="${2}" \
    _sum="${3}" \
    _index="${4}" \
    _chunk="${5}" \
    _payload \
    _passed_flag
  _msg=(
    "Checking chunk '${_chunk}'"
    "$(( "${_index}" + 1 ))"
    "of ${_chunks_total}."
  )
  _msg_info \
    "${_msg[*]}"
  _chunk_check_opts=(
    "${_fs_address}"
    "${_namespace}"
    "${_sum}"
    "${_index}"
    "${_chunk}"
  )
  _chunk_check \
    "${_chunk_check_opts[@]}"
  if [[ "${_passed_flag}" == "true" ]]; then
    _msg=(
      "Chunk '${_chunk}' correctly published"
      "already at index '${_index}'."
    )
    _msg_info \
      "${_msg[*]}"
    _verify_skip \
      "${_index}"
  elif [[ "${_passed_flag}" == "false" ]]; then
    _msg=(
      "Publishing chunk '${_chunk}'"
      "$(( "${_index}" + 1 ))"
      "of '${_chunks_total}'."
    )
    _msg_info \
      "${_msg[*]}"
    IFS= \
    read \
      -rd \
        '' \
      _payload < \
      <( cat \
           "${_chunk}" ) || \
      true
    evm-contract-call \
      "${_publish_call_opts[@]}" \
      "${_fs_address}" \
      "publishChunk" \
      "${_namespace}" \
      "${_sum}" \
      "${_index}" \
      "${_payload}"
    _msg=(
      "Published chunk"
      "$(( ${_index} + 1))"
      "of ${_chunks_total}."
    )
    _msg_info \
      "${_msg[*]}"
  fi
}

_contract_call_opts_setup() {
  local \
    _evm_contract_call_opts=() \
    _fs_call_opts=() \
    _msg=()
  _length_call_opts=()
  _length_lock_call_opts=()
  if [[ "${quiet}" == "n" ]]; then
    _length_lock_call_opts+=(
      -v
    )
  fi
  _evm_contract_call_opts+=(
    -n
      "${_target_network}"
    -N
      "${_wallet_name}"
    -k
      "${_api_key_path}"
  )
  if [[ "${_upload_method}" == "standalone" ]]; then
    _check_call_opts=()
    _publish_call_opts=()
    _verify_call_opts=()
    _lock_call_opts=()
    if [[ "${quiet}" == "n" ]]; then
      _publish_call_opts+=(
        -v
      )
      _lock_call_opts+=(
        -v
      )
    fi
    _fs_call_opts+=(
      "${_evm_contract_call_opts[@]}"
      -A
        "${_fs_abi}"
      -B
        "${_fs_bytecode}"
      -C
        "${_fs_compiler_output}"
    )
    _check_call_opts+=(
      "${_fs_call_opts[@]}"
      -t
        "static"
    )
    _publish_call_opts+=(
      "${_fs_call_opts[@]}"
      -t
        "dynamic"
      -T
        "${_call_timeout}"
    )
    _verify_call_opts+=(
      "${_fs_call_opts[@]}"
      -t
        "static"
    )
    _lock_call_opts+=(
      "${_fs_call_opts[@]}"
      -t
        "dynamic"
      -T
        "${_call_timeout}"
    )
  fi
  _length_call_opts+=(
    "${_evm_contract_call_opts[@]}"
    -A
      "${_ll_abi}"
    -B
      "${_ll_bytecode}"
    -C
      "${_ll_compiler_output}"
    -t
      "static"
  )
  _length_lock_call_opts+=(
    "${_evm_contract_call_opts[@]}"
    -A
      "${_ll_abi}"
    -B
      "${_ll_bytecode}"
    -C
      "${_ll_compiler_output}"
    -t
      "dynamic"
    -T
      "${_call_timeout}"
  )
  _msg=(
    "The EVM contract caller"
    "'evm-contract-call' will be called"
    "with base options '${_evm_contract_call_opts[*]}'."
  )
  _msg_info \
    "${_msg[*]}"
}

_work_dir_setup() {
  local \
    _msg=()
  _tmp_dir="${_cache_dir}/${_sum}/publish"
  _msg=(
    "setting up work directory"
    "'${_tmp_dir}'"
  )
  _msg_info \
    "${_msg[*]}"
  mkdir \
    -p \
    "${_tmp_dir}"
}

_file_encode() {
  local \
    _msg=() \
    _length
  _length=22000
  _chunk_prefix="$( \
    mktemp \
      -u \
      -p \
      "${_tmp_dir}" \
      --suffix=".base64")"
  _file_size_check \
    "${_file}"
  _bin2txt_opts+=(
    -L
      "${_length}"
  )
  if [[ "${quiet}" == "n" ]]; then
    _bin2txt_opts+=(
      -v
    )
  fi
  _msg=(
    "Encoding file with base64 encoding"
    "and splitting it into 22000 characters"
    "chunks."
  )
  _msg_info \
    "${_msg[*]}"
  if [[ "${_lock_only}" == "n" ]]; then
    bin2txt \
      "${_bin2txt_opts[@]}" \
      "${_file}" \
      "${_chunk_prefix}"
  fi
}

_queue_setup() {
  local \
    _chunk \
    _msg=() \
    _query
  if [[ "${_chunks_many}" == "true" ]]; then
    _query="${_chunk_prefix}."
  elif [[ "${_chunks_many}" == "false" ]]; then
    _query="${_chunk_prefix}"
  fi
  if [[ "${_lock_only}" == "n" ]]; then
    _chunks_total="$( \
      find \
        "${_query}"* \
        -type \
          "f" \
        -printf \
          '.' | \
        wc \
          -c)"
    if [[ "${_chunks_total}" == "1" ]]; then
      _publish_queue+=(
        "${_chunk_prefix}"
      )
      _verify_queue+=(
        "true"
      )
    elif (( 1 < "${_chunks_total}")); then
      for _chunk \
        in $(seq \
               "${_chunks_total}"); do
        _publish_queue+=(
          "${_chunk_prefix}.${_chunk}"
        )
        _verify_queue+=(
          "true"
        )
      done
    fi
  elif [[ "${_lock_only}" == "y" ]]; then
    _chunks_total="$( \
      bin2txt \
        -L \
          22000 \
        -s \
          "${_file}")"
    _publish_queue+=(
      $(seq \
          "${_chunks_total}")
    )
  fi
  if [[ "${_publish_queue[*]}" == "" ]]; then
    _msg_error \
      "error processing file for upload" \
      1
  fi
  _msg=(
    "upload queue: ${_publish_queue[*]}"
  )
  _msg_info \
    "${_msg[*]}"
}

_verify_skip() {
  local \
    _index="${1}"
  _verify_queue["${_index}"]="false"
}

_checkpoint_get() {
  local \
    _checkpoint_file_path="${1}" \
    _msg=()
  if [[ -e "${_checkpoint_file_path}" ]]; then
    _checkpoint="$( \
      cat \
        "${_checkpoint_file_path}")"
    _msg=(
      "Checkpoint is '${_checkpoint}'."
    )
    _msg_info \
      "${_msg[*]}"
    _run_once="true"
  else
    _msg=(
      "Checkpoint file does not exist."
      "Setting checkpoint to '${_index_start}'."
    )
    _msg_info \
      "${_msg[*]}"
    _checkpoint="${_index_start}"
    _run_once="false"
  fi
}

_chunks_publish_bulk() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _publish \
    _publish_args=() \
    _rpc_backend \
    _msg=() \
    _checkpoint_publish_file_path \
    _index_start \
    _index_end \
    _checkpoint \
    _chunks_total_run \
    _node_run_opts=() \
    _run_once
  _node_run_opts+=(
    -r
      "${_retries_max}"
  )
  _checkpoint_publish_file_path="${_tmp_dir}/checkpoint.publish"
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1))"
  _msg=(
    "Publishing '${_chunks_total_run}'"
    "chunks from '${_index_start}'"
    "to '${_index_end}'."
  )
  _msg_info \
    "${_msg[*]}"
  _rpc_backend_get \
    "${_target_network}"
  _publish="$( \
    _get_lib)/evmfs/publish"
  while true; do
    _checkpoint_get \
      "${_checkpoint_publish_file_path}"
    if [[ "${_checkpoint}" == "${_index_end}" && \
          "${_run_once}" == "true" ]]; then
      _msg=(
        "All '${_chunks_total_run}' chunks published."
      )
      _msg_info \
        "${_msg[*]}"
      rm \
        -rf \
        "${_checkpoint_publish_file_path}"
      break
    fi
    _msg_info \
      "Preparing node arguments."
    _publish_args=(
      "${quiet}"
      "${_retries_max}"
      "${_call_timeout}"
      "${_wallet_seed}"
      "${_api_key_path}"
      "${_rpc_backend}"
      "${_fs_address}"
      "${_fs_abi}"
      "${_fs_bytecode}"
      "${_fs_compiler_output}"
      "${_namespace}"
      "${_sum}"
      "${_checkpoint}"
      "${_index_end}"
      "${_checkpoint_publish_file_path}"
      "${_publish_queue[@]:${_checkpoint}:${_chunks_total_run}}"
    )
    _msg_info \
      "Running node."
    node-run \
      "${_node_run_opts[@]}" \
      "${_publish}" \
      "${_publish_args[@]}"
  done
}

_chunks_verify_bulk() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _verify \
    _verify_args=() \
    _rpc_backend \
    _msg=() \
    _checkpoint_verify_file_path \
    _index_start \
    _index_end \
    _checkpoint \
    _node_run_opts=() \
    _run_once
  _node_run_opts+=(
    -r
      "${_retries_max}"
  )
  _checkpoint_verify_file_path="${_tmp_dir}/checkpoint.verify"
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1))"
  _msg=(
    "Verifying '${_chunks_total_run}' published"
    "chunks going from index '${_index_start}'"
    "to index '${_index_end}'."
  )
  _msg_info \
    "${_msg[*]}"
  _rpc_backend_get \
    "${_target_network}"
  _verify="$( \
    _get_lib)/evmfs/verify"
  while true; do
    _checkpoint_get \
      "${_checkpoint_verify_file_path}"
    if [[ "${_checkpoint}" == "${_index_end}" && \
          "${_run_once}" == "true" ]]; then
      _msg=(
        "All '${_chunks_total_run}' indexes verified."
      )
      _msg_info \
        "${_msg[*]}"
      rm \
        -rf \
        "${_checkpoint_verify_file_path}"
      break
    fi
    _verify_args=(
      "${quiet}"
      "${_retries_max}"
      "${_api_key_path}"
      "${_rpc_backend}"
      "${_fs_address}"
      "${_fs_abi}"
      "${_fs_bytecode}"
      "${_fs_compiler_output}"
      "${_namespace}"
      "${_sum}"
      "${_checkpoint_verify_file_path}"
      "${_chunk_prefix}"
      $(seq \
          "${_checkpoint}" \
          "${_index_end}")
    )
    node-run \
      "${_node_run_opts[@]}" \
      "${_verify}" \
      "${_verify_args[@]}"
  done
}

_chunks_lock_bulk() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _lock \
    _lock_args=() \
    _rpc_backend \
    _msg=() \
    _checkpoint_lock_file_path \
    _index_start \
    _index_end \
    _checkpoint \
    _node_run_opts=() \
    _run_once
  _node_run_opts+=(
    -r
      "${_retries_max}"
  )
  _checkpoint_lock_file_path="${_tmp_dir}/checkpoint.lock"
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1))"
  _msg=(
    "Locking '${_chunks_total_run}' verified"
    "chunks going from index '${_index_start}'"
    "to index '${_index_end}'."
  )
  _msg_info \
    "${_msg[*]}"
  _rpc_backend_get \
    "${_target_network}"
  _lock="$( \
    _get_lib)/evmfs/lock"
  while true; do
    _checkpoint_get \
      "${_checkpoint_lock_file_path}"
    if [[ "${_checkpoint}" == "${_index_end}" && \
          "${_run_once}" == "true" ]]; then
      _msg=(
        "All '${_chunks_total_run}' chunks"
        "correctly locked."
      )
      _msg_info \
        "${_msg[*]}"
      rm \
        -rf \
        "${_checkpoint_lock_file_path}"
      break
    fi
    _lock_args=(
      "${quiet}"
      "${_retries_max}"
      "${_call_timeout}"
      "${_wallet_seed}"
      "${_api_key_path}"
      "${_rpc_backend}"
      "${_fs_address}"
      "${_fs_abi}"
      "${_fs_bytecode}"
      "${_fs_compiler_output}"
      "${_namespace}"
      "${_sum}"
      "${_checkpoint}"
      "${_index_end}"
      "${_checkpoint_lock_file_path}"
    )
    node-run \
      "${_node_run_opts[@]}" \
      "${_lock}" \
      "${_lock_args[@]}"
  done
}

# NOTE: This parallel processes method
# is currently unused.
_chunks_publish_new() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _chunk \
    _index \
    _pending \
    _pendings=() \
    _msg=() \
    _job
  _index=0
  while \
    [ "${_index}" -le "$(("${_chunks_total}" - 1))" ] && \
    [ "${#_pendings}" -le "${_tasks_parallel}" ]; do
    _chunk="${_publish_queue["${_index}"]}"
    _chunk_publish_opts=(
      "${_fs_address}"
      "${_namespace}"
      "${_sum}"
      "${_index}"
      "${_chunk}"
    )
    _run \
      "publish_chunk_${_index}" \
      "0" \
      "async" \
      _chunk_publish \
        "${_chunk_publish_opts[@]}" || \
      true
    _pendings+=(
      "$(_get_pid \
	   "publish_chunk_${_index}")"
    )
    _index="$(( \
      _index + 1 ))"
    if [[ "${#_pendings}" == "${_tasks_parallel}" ]]; then 
      wait \
	-f \
	-p \
	  _job \
        -n \
        "${_pendings[@]}"
      _pendings_new=()
      for _pending in "${_pendings[@]}"; do
        if [[ "${_pending}" != "${_job}" ]]; then
          _pendings_new+=(
            "${_pending}"
          )
        fi
      done
      _pendings=(
        "${_pendings_new[@]}"
      )
      _job=""
    fi
  done
}

_chunks_publish_standalone() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _chunk \
    _index \
    _msg=() \
    _chunks_total_run
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1))"
  _index="${_index_start}"
  for _chunk \
    in "${_publish_queue[@]:${_index_start}:${_chunks_total_run}}"; do
    _chunk_publish_opts=(
      "${_fs_address}"
      "${_namespace}"
      "${_sum}"
      "${_index}"
      "${_chunk}"
    )
    _chunk_publish \
      "${_chunk_publish_opts[@]}"
    _index="$(( \
      _index + 1))"
  done
  _msg=(
    "All '${_chunks_total_run}' chunks"
    "correctly published."
  )
  _msg_info \
    "${_msg[*]}"
}

_chunks_verify_standalone() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _index \
    _chunk \
    _msg=() \
    _chunks_total_run
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1))"
  _index="${_index_start}"
  for _chunk \
    in "${_publish_queue[@]:${_index_start}:${_chunks_total_run}}"; do
    _msg=(
      "Verifying '${_chunks_total_run}' published"
      "chunks going from index '${_index_start}'"
      "to index '${_index_end}'."
    )
    _msg_info \
      "${_msg[*]}"
    if [[ "${_verify_queue["${_index}"]}" == "true" ]]; then
      _chunk_verify_opts=(
        "${_fs_address}"
        "${_namespace}"
        "${_sum}"
        "${_index}"
        "${_chunk}"
      )
      _chunk_verify \
        "${_chunk_verify_opts[@]}"
      _msg=(
        "Verified chunk '${_chunk}'"
        "($(( "${_index}" + 1 ))"
        "of ${_chunks_total_run})."
      )
      _msg_info \
        "${_msg[*]}"
      _index="$(( \
        _index + 1))"
    elif [[ "${_verify_queue["${_index}"]}" == "false" ]]; then
      _msg=(
        "Chunk '${_chunk}'"
        "($(( "${_index}" + 1 ))"
        "of ${_chunks_total_run})"
        "already verified."
      )
      _msg_info \
        "${_msg[*]}"
    fi
  done
  _msg=(
    "All '${_chunks_total_run}' chunks"
    "correctly verified."
  )
  _msg_info \
    "${_msg[*]}"
}

_chunks_lock_new() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _index \
    _chunk \
    _pendings=()
    _msg=()
  _index=0
  while \
    [ "${_index}" -le "$(("${_chunks_total}" - 1))" ] && \
    [ "${#_pendings}" -le "${_tasks_parallel}" ]; do
    _chunk="${_publish_queue["${_index}"]}"
    _msg=(
      "locking chunk '${_chunk}'"
      "$(( "${_index}" + 1))"
      "of ${_chunks_total}"
    )
    _msg_info \
      "${_msg[*]}"
    _run \
      "lock_chunk_${_index}" \
      "0" \
      "async" \
      _chunk_lock \
        "${_fs_address}" \
        "${_namespace}" \
        "${_sum}" \
        "${_index}" || \
      true
    _pendings+=(
      "$(_get_pid \
           "lock_chunk_${_index}")"
    )
    if [[ "${#_pendings}" == "${_tasks_parallel}" ]]; then 
      wait \
        -f \
        -p \
          _job \
        -n \
        "${_pendings[@]}"
      _pendings_new=()
      for _pending in "${_pendings[@]}"; do
        if [[ "${_pending}" != "${_job}" ]]; then
          _pendings_new+=(
            "${_pending}"
          )
        fi
      done
      _pendings=(
        "${_pendings_new[@]}"
      )
      _job=""
    fi
    _index="$(( \
      _index + 1))"
  done
  wait \
    "${_pendings[@]}"
  _msg=(
    "all '${_chunks_total}' chunks"
    "correctly locked."
  )
  _msg_info \
    "${_msg[*]}"
}

_chunks_lock_standalone() {
  local \
    _tasks_parallel="${1}" \
    _index_start="${2}" \
    _index_end="${3}" \
    _index \
    _chunk \
    _locked \
    _msg=() \
    _chunks_total_run
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1 ))"
  _index="${_index_start}"
  for _chunk \
    in "${_publish_queue[@]:${_index_start}:${_chunks_total_run}}"; do
    _msg=(
      "Locking chunk '${_chunk}'"
      "($(( "${_index}" + 1))"
      "of ${_chunks_total})."
    )
    _msg_info \
      "${_msg[*]}"
    _chunk_lock \
      "${_fs_address}" \
      "${_namespace}" \
      "${_sum}" \
      "${_index}"
    _index="$(( \
      _index + 1))"
  done
  _msg=(
    "All '${_chunks_total}' chunks"
    "correctly locked."
  )
  _msg_info \
    "${_msg[*]}"
}

_chunks_length_lock() {
  local \
    _fs_address="${1}" \
    _chunks_total="${2}" \
    _locked \
    _length \
    _msg=()
  _length="$(( \
    _chunks_total - 1))"
  _msg=(
    "Checking length lock."
  )
  _msg_info \
    "${_msg[*]}"
  _locked="$( \
    evm-contract-call \
      "${_length_call_opts[@]}" \
      "${_ll_address}" \
      "lock" \
      "${_fs_address}" \
      "${_namespace}" \
      "${_sum}")"
  if [[ "${_locked}" == "false" ]]; then
    _msg=(
      "Length unlocked, locking at '${_length}'."
    )
    _msg_info \
      "${_msg[*]}"
    evm-contract-call \
      "${_length_lock_call_opts[@]}" \
      "${_ll_address}" \
      "setLength" \
      "${_fs_address}" \
      "${_namespace}" \
      "${_sum}" \
      "${_length}"
    _msg=(
      "Locked length '${_length}'."
    )
  elif [[ "${_locked}" == "true" ]]; then
    _msg=(
      "Length already locked at '${_length}'."
    )
  elif [[ "${_locked}" == "" ]]; then
    _msg=(
      "Error retrieving length lock state."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _msg_info \
    "${_msg[*]}"
}

_chunk_check() {
  local \
    _contract="${1}" \
    _namespace="${2}" \
    _sum="${3}" \
    _index="${4}" \
    _chunk="${5}" \
    _remote \
    _check_dir \
    _local_sum \
    _remote_sum \
    _msg=()
  _passed_flag="false"
  _check_dir="${_cache_dir}/${_sum}/check"
  _remote="${_check_dir}/${_index}"
  mkdir \
    -p \
    "${_check_dir}"
  evm-contract-call \
    "${_check_call_opts[@]}" \
    "${_fs_address}" \
    "chunks" \
    "${_namespace}" \
    "${_sum}" \
    "${_index}" > \
    "${_remote}"
  _local_sum="$( \
    _file_hash \
      "${_chunk}")"
  _remote_sum="$( \
    _file_hash \
      "${_remote}")"
  if [[ "${_local_sum}" == "${_remote_sum}" ]]; then
    _passed_flag="true"
  fi
}

_chunks_network_assignment() {
  _chunks_total_network="$(( \
    "${_chunks_total}" / \
    "${_networks_amount}"))"
  _chunks_remainder_network="$(( \
    "${_chunks_total}" - \
    ( "${_chunks_total_network}" * \
      "${_networks_amount}" ) ))"
}

_index_network_get() {
  if [[ "${_network}" == "1" ]]; then
    _index_start=0
  else
    _index_start="$(( \
      "${_index_end}" + 1))"
  fi
  if ! (( "${_chunks_remainder_network}" < \
          "${_network}" )); then
      _index_end="$(( \
        "${_index_start}" + \
        "${_chunks_total_network}"))"
  else
    _index_end="$(( \
      "${_index_start}" + \
      "${_chunks_total_network}" - 1))"
  fi
}

_fs_address_get() {
  if [[ "${_networks_amount}" == 1 ]]; then
    _fs_address=""
    _contract_address_auto_detect \
      "evmfs" \
      "FileSystem" \
      "_fs" \
      "${_target_networks[0]}" \
      "${_fs_version}" \
      "${_user_level}" \
      "${_deployments_dir}"
  elif (( 1 < "${_networks_amount}" )); then
    _fs_address=""
    _contract_address_auto_detect \
      "evmfs" \
      "FileSystem" \
      "_fs" \
      "${_target_network}" \
      "${_fs_version}" \
      "${_user_level}" \
      "${_deployments_dir}"
  fi
}

_index_publish_bulk() {
  local \
    _tasks_parallel="${1}" \
    _target_network="${2}" \
    _fs_address="${3}" \
    _index_start="${4}" \
    _index_end="${5}" \
    _index \
    _index_args=() \
    _rpc_backend \
    _msg=() \
    _checkpoint_index_file_path \
    _index_start \
    _index_end \
    _checkpoint \
    _chunks_total_run \
    _node_run_opts=() \
    _run_once
  _node_run_opts+=(
    -r
      "${_retries_max}"
  )
  _checkpoint_index_file_path="${_tmp_dir}/checkpoint.index"
  _chunks_total_run="$(( \
    "${_index_end}" - "${_index_start}" + 1))"
  _msg=(
    "Indexing '${_chunks_total_run}' locked"
    "chunks from index '${_index_start}'"
    "to index '${_index_end}'."
  )
  _msg_info \
    "${_msg[*]}"
  _rpc_backend_get \
    "${_target_networks[0]}"
  _index="$( \
    _get_lib)/evmfs/index"
  while true; do
    _checkpoint_get \
      "${_checkpoint_index_file_path}"
    if [[ "${_checkpoint}" == "${_index_end}" && \
          "${_run_once}" == "true" ]]; then
      _msg=(
        "All '${_chunks_total_run}' chunks'"
        "locations published."
      )
      _msg_info \
        "${_msg[*]}"
      rm \
        -rf \
        "${_checkpoint_index_file_path}"
      break
    fi
    _msg_info \
      "Preparing node arguments."
    _index_args=(
      "${quiet}"
      "${_retries_max}"
      "${_call_timeout}"
      "${_wallet_seed}"
      "${_api_key_path}"
      "${_rpc_backend}"
      "${_ccfs_address}"
      "${_ccfs_abi}"
      "${_ccfs_bytecode}"
      "${_ccfs_compiler_output}"
      "${_namespace}"
      "${_sum}"
      "${_checkpoint}"
      "${_index_end}"
      "${_target_network}"
      "${_fs_address}"
      "${_checkpoint_index_file_path}"
    )
    _msg_info \
      "Running node."
    node-run \
      "${_node_run_opts[@]}" \
      "${_index}" \
      "${_index_args[@]}"
  done
}

_target_ll_fs_address_get() {
  if [[ "${_networks_amount}" == 1 ]]; then
    _fs_address_get
    _target_ll_fs_address="${_fs_address}"
  elif (( 1 < "${_networks_amount}" )); then
    _target_ll_fs_address="${_ccfs_address}"
  fi
  _msg=(
    "Length lock contract"
    "target fs address is"
    "'${_target_ll_fs_address}'."
  )
  _msg_info \
    "${_msg[*]}"
}

_file_upload() {
  local \
    _ccfs_address="${1}" \
    _namespace="${2}" \
    _file="${3}" \
    _upload_method="${4}" \
    _chunks_many \
    _sum \
    _publish_queue=() \
    _verify_queue=() \
    _chunks_total \
    _tmp_dir \
    _chunk_prefix \
    _bin2txt_opts=() \
    _length_call_opts=() \
    _length_lock_call_opts=() \
    _ccfs_abi \
    _ccfs_bytecode \
    _ccfs_compiler_output \
    _cursor \
    _network \
    _target_network \
    _target_networks=() \
    _chunks_total_network \
    _chunks_remainder_network \
    _index_start \
    _index_end \
    _fs_abi \
    _fs_bytecode \
    _fs_compiler_output \
    _target_ll_fs_address \
    _ll_abi \
    _ll_bytecode \
    _ll_compiler_output \
    _chunk \
    _payload \
    _check_call_opts=() \
    _publish_call_opts=() \
    _verify_call_opts=() \
    _lock_call_opts=() \
    _chunk_publish_opts=() \
    _msg=() \
    _publishing_address
  shift \
    4
  _target_networks+=(
    "$@"
  )
  _msg=(
    "Re-evaluating file hashsum."
  )
  _msg_info \
    "${_msg[*]}"
  _sum="$( \
    _file_hash \
      "${_file}")"
  _work_dir_setup
  _file_encode
  _queue_setup
  _chunks_network_assignment 
  _target_ll_fs_address_get
  _contract_artifacts_auto_detect \
    "${_deployments_dir}" \
    "${_target_networks[0]}" \
    "LengthLock" \
    "_ll" \
    "${_fs_version}"
  if (( 1 < "${_networks_amount}" )); then
    _contract_artifacts_auto_detect \
      "${_deployments_dir}" \
      "${_target_networks[0]}" \
      "CrossChainFileSystem" \
      "_ccfs" \
      "${_fs_version}"
  fi
  _cursor=0
  for _network \
    in $(seq \
           "${_networks_amount}"); do
    _index_network_get
    _target_network="${_target_networks["${_cursor}"]}"
    _fs_address_get
    _contract_artifacts_auto_detect \
      "${_deployments_dir}" \
      "${_target_network}" \
      "FileSystem" \
      "_fs" \
      "${_fs_version}"
    _contract_call_opts_setup
    _msg_info \
      "index start: ${_index_start}"
     _msg_info \
      "index end: ${_index_end}"
    if ! (( "${_index_end}" < "${_index_start}" )); then
      if [[ "${_lock_only}" == "n" ]]; then
        "_chunks_publish_${_upload_method}" \
          "${_tasks_parallel}" \
          "${_index_start}" \
          "${_index_end}"
        "_chunks_verify_${_upload_method}" \
          "${_tasks_parallel}" \
          "${_index_start}" \
          "${_index_end}"
      fi
      "_chunks_lock_${_upload_method}" \
        "${_tasks_parallel}" \
        "${_index_start}" \
        "${_index_end}"
      if (( 1 < "${_networks_amount}" )); then
        "_index_publish_${_upload_method}" \
          "${_tasks_parallel}" \
          "${_target_network}" \
          "${_fs_address}" \
          "${_index_start}" \
          "${_index_end}"
      fi
    fi
    _cursor="$(( \
      "${_cursor}" + 1))"
  done
  _target_network="${_target_networks[0]}"
  _contract_call_opts_setup
  _chunks_length_lock \
    "${_target_ll_fs_address}" \
    "${_chunks_total}"
  _publishing_address="$( \
    _publishing_address_get \
      "${_file}")"
  _msg=(
    "File '${_file}' uploaded and"
    "available at URI"
    "'${_publishing_address}'."
  )
  _msg_info \
    "${_msg[*]}"
}

_evmfs_publish() {
  local \
    _fs_address="${1}" \
    _ll_address="${2}" \
    _ccfs_address="${3}" \
    _fs_version="${4}" \
    _deployments_dir="${5}" \
    _user_level="${6}" \
    _wallet_name="${7}" \
    _wallet_path="${8}" \
    _wallet_password="${9}" \
    _wallet_seed="${10}" \
    _networks_amount="${11}" \
    _api_key_path="${12}" \
    _upload_method="${13}" \
    _retries_max="${14}" \
    _call_timeout="${15}" \
    _lock_only="${16}" \
    _tasks_parallel="${17}" \
    _cache_dir="${18}" \
    _target_file \
    _target_files=() \
    _target_networks=() \
    _command_args=() \
    _msg=() \
    _cmd \
    _args=() \
    _namespace
  shift \
    18
  for _network \
    in $(seq "${_networks_amount}"); do
    _target_networks+=(
      "${1}"
    )
    shift
  done
  _target_files+=(
    "$@"
  )
  _namespace="$( \
    evm-wallet \
     get \
       "${_wallet_name}" \
       "address")"
  for _target_file in "${_target_files[@]}"; do
    if [[ "${_upload_method}" == "bulk" || \
          "${_upload_method}" == "standalone" ]]; then
      _file_upload \
        "${_ccfs_address}" \
        "${_namespace}" \
        "${_target_file}" \
        "${_upload_method}" \
        "${_target_networks[@]}"
    elif [[ "${_upload_method}" == "simulate" ]]; then
      _publishing_address_get \
        "${_target_file}"
    else
      _msg=(
        "Unknown upload"
        "method '${_upload_method}'."
      )
      _msg_error \
        "${_msg[*]}" \
        1
    fi
  done
}

_set_overrides() {
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
  if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  _set_override \
    "publish" \
    "date" \
    "$(_get_date_human)"
  _set_override \
    "wallet" \
    "name" \
    "default"
  _set_override \
    "user" \
    "level" \
    "n"
  _deployments_dir_auto_detect \
    "evmfs" \
    "${user_level}"
  networks_amount="${#target_networks[@]}"
  if (( "${networks_amount}" < 1 )); then
    _network_auto_detect \
      "FileSystem" \
      "${deployments_dir}" \
      "${user_level}"
    target_networks+=(
      "${target_network}"
    )
    target_network=""
    networks_amount="${#target_networks[@]}"
  fi
  _set_override \
    "wallet" \
    "path" \
    "$(_wallet_path_get \
         "evm-wallet" \
         "${wallet_name}")"
  _secret_auto_detect \
    "seed" \
    "seed" \
    "evm-wallet" \
    "${wallet_name}"
  _secret_auto_detect \
    "password" \
    "plain" \
    "evm-wallet" \
    "${wallet_name}"
  _set_override \
    "wallet" \
    "address" \
    "$(evm-wallet \
         get \
           "${wallet_name}" \
           "address")"
  _set_override \
    "cache" \
    "dir" \
    "$(_cache_dir_auto_detect)"
  _set_override \
    "upload" \
    "method" \
    "bulk"
  _set_override \
    "lock" \
    "only" \
    "n"
  _set_override \
    "tasks" \
    "parallel" \
    "2"
  _set_override \
    "retries" \
    "max" \
    "300"
  _set_override \
    "call" \
    "timeout" \
    "300000"
  _contract_version_auto_detect \
    "${deployments_dir}" \
    "FileSystem" \
    "fs" \
    "${target_networks[0]}"
  if [[ "${fs_version}" == "1.0" ]]; then
    _contract_address_auto_detect \
      "evmfs" \
      "LengthLock" \
      "ll" \
      "${target_networks[0]}" \
      "${fs_version}" \
      "${user_level}" \
      "${deployments_dir}"
  fi
  if [[ "${networks_amount}" == 1 ]]; then
    _api_key_auto_detect \
      "${target_networks[0]}"
    _contract_address_auto_detect \
      "evmfs" \
      "FileSystem" \
      "fs" \
      "${target_networks[0]}" \
      "${fs_version}" \
      "${user_level}" \
      "${deployments_dir}"
    _set_override \
      "ccfs" \
      "address" \
      ""
  elif (( 1 < "${networks_amount}" )); then
    _contract_address_auto_detect \
      "evmfs" \
      "CrossChainFileSystem" \
      "ccfs" \
      "${target_networks[0]}" \
      "${fs_version}" \
      "${user_level}" \
      "${deployments_dir}"
    _set_override \
      "fs" \
      "address" \
      ""
  fi
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _fs_deployment \
    _networks \
    _usage_text
  _fs_deployment="${deployments_dir}/FileSystem"
  _networks=( $( \
    evm-contract-deployment-networks \
      -A \
      "${_fs_deployment}")
  )
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true
EVM network file system file publisher

Usage:
  ${app_name}
    [options]
    <file>

  networks:
$(_display_networks \
     "${_networks[@]}")

  options:
     -A <fs_address>        Address of the FileSystem contract
                            on the network.
                            Default: ${fs_address}
     -B <ll_address>        Address of the LengthLock contract
                            on the network.
                            Default: ${ll_address}
     -C <ccfs_address>      Address of the CrossChainFileSystem
                            contract on the network.
                            Default: ${ccfs_address}
     -V <fs_version>        Version of the target EVM file
                            system.
                            Default: ${fs_version}
     -u                     Whether to retrieve file system
                            address from user directory or custom
                            deployment.
                            Default: ${user_level}
     -d <deployments_dir>   Contracts deployments directory.
                            Default: ${deployments_dir}
     -N <wallet_name>       Wallet name.
                            Default: ${wallet_name}
     -w <wallet_path>       Wallet path.
                            Default: ${wallet_path}
     -p <wallet_password>   Wallet password.
                            Default: ${wallet_password}
     -s <wallet_seed>       Wallet seed path.
                            Default: ${wallet_seed}
     -n <network>           EVM network name (${_networks[*]}).
                            Default: ${target_network}
     -k <api_key>           Etherscan-like service key.
                            Default: ${api_key}
     -m <upload_method>     It can be 'standalone' or 'simulate'.
                            Default: ${upload_method}
     -r <retries_max>       Maximum number of retries before
                            failing.
                            Default: ${retries_max}
     -T <call_timeout>      Maximum number of milliseconds before
                            declaring the call failed.
                            Default: ${call_timeout}
     -L                     Skip check and publish and only lock
                            the file.
                            Default: ${lock_only}
     -P <tasks_parallel>    Tasks to perform in parallel.
                            Default: ${tasks_parallel}
     -W <cache_dir>         Work directory.
                            Default: ${cache_dir}

     -h                     This message.
     -c                     Enable color output
     -v                     Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${1}"
}

_publishing_address_get() {
  local \
    _file="${1}" \
    _network \
    _fs_address \
    _namespace \
    _file \
    _sum
  _network="${target_networks[0]}"
  _fs_address="${fs_address}"
  if [[ "${_fs_address}" == "" ]]; then
    _fs_address="${ccfs_address}"
  fi
  _namespace="${wallet_address}"
  _sum="$( \
    _file_hash \
      "${_file}")"
  echo \
    "evmfs://${_network}/${_fs_address}/${_namespace}/${_sum}"
}

_display_flags() {
  local \
    _flag \
    _flags=(
      "${1}"
    )
  for _flag \
    in "${_flags[@]}"; do
  _msg_info \
    "                             ${_flag}"
  done
}

# Shows configuration options.
_show_config() {
  _msg_info "${app_name} configuration"
  _msg_info "                   Publish date:   ${publish_date}"
  _msg_info "Cross-chain file system address:   ${ccfs_address}"
  _msg_info "            File system address:   ${fs_address}"
  _msg_info "            File system version:   ${fs_version}"
  _msg_info "             LengthLock address:   ${ll_address}"
  _msg_info "                     User level:   ${user_level}"
  _msg_info "          Deployments directory:   ${deployments_dir}"
  _msg_info "                      Namespace:   ${wallet_address}"
  _msg_info "                    Wallet name:   ${wallet_name}"
  _msg_info "                    Wallet path:   ${wallet_path}"
  _msg_info "                Wallet password:   ${wallet_password}"
  _msg_info "                    Wallet seed:   ${wallet_seed}"
  _msg_info "                Target networks:   ${target_networks[*]}"
  _msg_info "                        API key:   ${api_key}"
  _msg_info "                  Upload method:   ${upload_method}"
  _msg_info "                Maximum retries:   ${retries_max}"
  _msg_info "                   Call timeout:   ${call_timeout}"
  _msg_info "                      Lock only:   ${lock_only}"
  _msg_info "                 Tasks parallel:   ${tasks_parallel}"
  _msg_info "                Cache directory:   ${cache_dir}"
  _msg_info "                   Target files:"
  _display_target_files                        "${target_files[@]}"
}

_display_target_files() {
  local \
    _target_files=() \
    _file \
    _address
  _target_files+=(
    "$@"
  )
  for _file \
    in "${_target_files[@]}"; do
    _address="$( \
      _publishing_address_get \
        "${_file}")"
    _msg_info "                           File:   ${_file}"
    _msg_info "             Publishing address:   ${_address}"
  done
}

_globals
_global_variables
_requirements
# shellcheck disable=SC2034
while \
  getopts \
    'A:B:C:V:ud:N:w:p:s:n:k:m:r:T:LP:W:cvh?' \
    arg; do
  case \
    "${arg}" in
    A) override_fs_address="${OPTARG}" ;;
    B) override_ll_address="${OPTARG}" ;;
    C) override_ccfs_address="${OPTARG}" ;;
    V) override_fs_version="${OPTARG}" ;;
    u) override_user_level="y" ;;
    d) override_deployments_dir="${OPTARG}" ;;
    N) override_wallet_name="${OPTARG}" ;;
    w) override_wallet_path="${OPTARG}" ;;
    p) override_wallet_password="${OPTARG}" ;;
    s) override_wallet_seed="${OPTARG}" ;;
    n) target_networks+=(
         "${OPTARG}"
       ) ;;
    k) override_api_key="${OPTARG}" ;;
    m) override_upload_method="${OPTARG}" ;;
    r) override_retries_max="${OPTARG}" ;;
    T) override_call_timeout="${OPTARG}" ;;
    L) override_lock_only="y" ;;
    P) override_tasks_parallel="${OPTARG}" ;;
    W) override_cache_dir="${OPTARG}" ;;
    c) override_color="y" ;;
    v) override_quiet="n" ;;
    h|?) _set_overrides && \
         _usage \
           0 ;;
    *)
    _msg_error \
      "Invalid argument '${arg}'." \
      0
    _usage \
      1
    ;;
  esac
done
shift \
  $(( \
    OPTIND - 1 \
  ))
if (( $# < 1 )); then
  _msg_error \
    "No input file given." \
    0
  _set_overrides
  _usage \
    1
fi
for _file in "$@"; do
  if [[ ! -e "${_file}" ]]; then
    _msg=(
      "File '${_file}' does not exists."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  target_files+=(
    "$(realpath \
         "${1}")"
  )
done
_set_overrides
_show_config
app_opts=(
  "${fs_address}"
  "${ll_address}"
  "${ccfs_address}"
  "${fs_version}"
  "${deployments_dir}"
  "${user_level}"
  "${wallet_name}"
  "${wallet_path}"
  "${wallet_password}"
  "${wallet_seed}"
  "${networks_amount}"
  "${api_key}"
  "${upload_method}"
  "${retries_max}"
  "${call_timeout}"
  "${lock_only}"
  "${tasks_parallel}"
  "${cache_dir}"
  "${target_networks[@]}"
  "${target_files[@]}"
)
_evmfs_publish \
  "${app_opts[@]}"

# vim:set sw=2 sts=-1 et:
